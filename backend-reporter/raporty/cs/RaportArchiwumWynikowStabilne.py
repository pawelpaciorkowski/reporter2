import base64
import io
import zipfile
import tempfile
import os
import traceback

from dialog import Dialog, VBox, HBox, InfoText, TextInput, Select, Button, DynamicSelect, DateInput
from tasks import TaskGroup
from helpers import prepare_for_json
from datasources.postgres import PostgresDatasource
from config import Config
from flask import send_file

MENU_ENTRY = 'Raport Archiwum WynikÃ³w Labor (Multisync) vol2 test'

LAUNCH_DIALOG = Dialog(
    title=MENU_ENTRY,
    panel=VBox(
       

        HBox(
            # Sekcja: Wyszukiwanie po pacjencie lub dacie
            VBox(
                InfoText(text="Dane pacjenta i zakres dat"),
                TextInput(
                    field="pacjent_imie",
                    title="ImiÄ™ pacjenta",
                    required=False,
                    default=""
                ),
                TextInput(
                    field="pacjent_nazwisko",
                    title="Nazwisko pacjenta",
                    required=False,
                    default=""
                ),
                TextInput(
                    field="pacjent_pesel",
                    title="PESEL pacjenta",
                    required=False,
                    default=""
                ),
                DateInput(
                    field="pacjent_data_urodzenia",
                    title="Data urodzenia pacjenta",
                    required=False,
                    default=""
                ),
                DateInput(
                    field="zlecenie_data_od",
                    title="Data zlecenia od",
                    required=False,
                    default=""
                ),
                DateInput(
                    field="zlecenie_data_do",
                    title="Data zlecenia do",
                    required=False,
                    default=""
                ),
            ),

            # Sekcja: Dane zlecenia i lekarza
            VBox(
                InfoText(text="SzczegÃ³Å‚y zlecenia i lekarza"),
                TextInput(field="zlecenie_kod_kreskowy", title="Kod kreskowy zlecenia", required=False, default=""),
                TextInput(field="lekarz_imie", title="ImiÄ™ lekarza", required=False, default=""),
                TextInput(field="lekarz_nazwisko", title="Nazwisko lekarza", required=False, default=""),
                TextInput(field="zleceniodawca_nazwa", title="Nazwa zleceniodawcy", required=False, default=""),
                TextInput(field="zleceniodawca_kod_lsi", title="Kod LSI zleceniodawcy", required=False, default=""),
                TextInput(field="zleceniodawca_nip", title="NIP zleceniodawcy", required=False, default=""),
            ),

            # Sekcja: Generowanie plikÃ³w
            VBox(
                InfoText(text="Ustawienia generowania plikÃ³w"),
                DynamicSelect(
                    field="generate_pdf",
                    title="Czy chcesz pobraÄ‡ pliki z wynikami?",
                    required=False,
                    default="nie",
                    options=[]
                ),
                DynamicSelect(
                    field="pdf_mode",
                    title="Rodzaj PDF-a",
                    required=False,
                    default="single",
                    options=[]
                ),
                TextInput(
                    field="selected_ids",
                    title="Wybrane ID (oddzielone przecinkami)",
                    required=False,
                    default="",
                    help_text="Np. 12345,67890,22222"
                ),
                DynamicSelect(
                    field="typ_pliku",
                    title="Typ dokumentu do pobrania",
                    required=False,
                    default="pdf",
                    options=[]
                ),
                DynamicSelect(
                    field="format_cda",
                    title="Format dokumentu CDA (jeÅ›li wybrano CDA/XML)",
                    required=False,
                    default="pades",
                    options=[]
                )
            )
        )
    )
)



def get_generate_pdf_options(params):
    return [
        {"label": "Nie â€“ tylko wyÅ›wietl wyniki", "value": "nie"},
        {"label": "Tak â€“ pobierz pliki z aktualnej strony", "value": "tak"},
        {"label": "Tak â€“ pobierz wszystkie wyniki ze wszystkich stron", "value": "wszystkie"},
        {"label": "Tak â€“ pobierz z zaznaczonych checkboxÃ³w w tabeli", "value": "zaznaczone"},
    ]


def get_pdf_mode_options(params):
    return [
        {"label": "Oddzielne pliki PDF (dla kaÅ¼dego wyniku)", "value": "single"},
        {"label": "Jeden zbiorczy plik PDF", "value": "combined"},
    ]


def get_typ_pliku_options(params):
    return [
        {
            "label": "Raport PDF â€“ zbiorczy lub oddzielne pliki z wynikami badaÅ„",
            "value": "pdf"
        },
        {
            "label": "CDA (XML) â€“ oryginalne dokumenty zgodne ze standardem HL7 CDA",
            "value": "cda"
        }
    ]


def get_format_cda_options(params):
    return [
        {
            "label": "ðŸ“„ PDF â€“ gotowy do wydruku (z podpisem)",
            "value": "pades"
        },
        {
            "label": "ðŸ—Ž XML â€“ surowy dokument (dla systemÃ³w)",
            "value": "cda"
        }
    ]


def assign_widget_data(dialog):
    for field_name in ["generate_pdf", "pdf_mode", "typ_pliku", "format_cda"]:
        widget = dialog.get_field_by_name(field_name)
        if widget is not None:
            if field_name == "generate_pdf":
                widget.get_widget_data = get_generate_pdf_options
            elif field_name == "pdf_mode":
                widget.get_widget_data = get_pdf_mode_options
            elif field_name == "typ_pliku":
                widget.get_widget_data = get_typ_pliku_options
            elif field_name == "format_cda":
                widget.get_widget_data = get_format_cda_options

assign_widget_data(LAUNCH_DIALOG)

def start_report(params):
    if params.get('action') == 'clear_filters':
        return {"type": "clear"}

    # ObsÅ‚uga paginacji
    page = int(params.get('page', 1))
    page_size = int(params.get('page_size', 50))
    fetch_all = params.get('fetch_all', 'false')
    offset = int(params.get('offset', 0))  # Dodaj obsÅ‚ugÄ™ offset
    
    params = LAUNCH_DIALOG.load_params(params)
    params['page'] = page
    params['page_size'] = page_size
    params['fetch_all'] = fetch_all
    params['offset'] = offset  # PrzekaÅ¼ offset
    
    print(f"DEBUG - start_report: page={page}, page_size={page_size}, fetch_all={fetch_all}, offset={offset}")
    
    report = TaskGroup(__PLUGIN__, params)
    task = {
        'type': 'ick',
        'priority': 0,
        'params': params,
        'function': 'raport',
    }
    report.create_task(task)
    report.save()
    return report

def raport(task_params):
    db = PostgresDatasource(Config.DATABASE_MULTISYNC_LABOR_ARCHIWUM)
    params = task_params.get('params', {})
    print(f"DEBUG - Wszystkie parametry otrzymane: {params}")
    print(f"DEBUG - generate_pdf wartoÅ›Ä‡: {params.get('generate_pdf')}")
    
    generate_pdf = params.get('generate_pdf') == 'tak'
    generate_all_from_page = params.get('generate_pdf') == 'wszystkie'
    generate_selected = params.get('generate_pdf') == 'zaznaczone'
    generate_background = params.get('generate_pdf') == 'background'
    
    print(f"DEBUG - generate_pdf={generate_pdf}, generate_all_from_page={generate_all_from_page}, generate_selected={generate_selected}, generate_background={generate_background}")
    selected_ids = params.get('selected_ids')
    file_type = params.get("typ_pliku", "pdf")
    format_cda = params.get("format_cda", "cda")
    
    # ObsÅ‚uga paginacji - pobierz wszystkie dane za jednym razem
    fetch_all = params.get('fetch_all', False)  # Nowy parametr
    page = int(params.get('page', 1))
    page_size = int(params.get('page_size', 50))
    offset = (page - 1) * page_size
    
    print(f"DEBUG - Paginacja: page={page}, page_size={page_size}, offset={offset}, fetch_all={fetch_all}")

    conditions = []
    values = []
    
    
    # Sprawdzenie czy podano przynajmniej dwa filtry
    active_filters = [
        params.get('pacjent_imie'),
        params.get('pacjent_nazwisko'),
        params.get('pacjent_pesel'),
        params.get('pacjent_data_urodzenia'),
        params.get('zlecenie_data_od'),
        params.get('zlecenie_data_do'),
        params.get('zlecenie_kod_kreskowy'),
        params.get('lekarz_imie'),
        params.get('lekarz_nazwisko'),
        params.get('zleceniodawca_nazwa'),
        params.get('zleceniodawca_kod_lsi'),
        params.get('zleceniodawca_nip')
    ]
    
    active_filters_count = sum(1 for filter_value in active_filters if filter_value)
    
    # Specjalna logika: jeÅ›li podano tylko NIP, pozwÃ³l na wyszukiwanie
    only_nip_filter = (active_filters_count == 1 and params.get('zleceniodawca_nip'))
    
    if not generate_pdf and not generate_all_from_page and not generate_selected and active_filters_count < 2 and not only_nip_filter:
        return {
            "type": "info", 
            "text": "Musisz podaÄ‡ przynajmniej dwa filtry, aby uruchomiÄ‡ wyszukiwanie. WypeÅ‚nij co najmniej dwa pola w formularzu."
        }


    # Wyszukiwanie po danych pacjenta
    if params.get('pacjent_imie'):
        conditions.append('pacjent_imie ILIKE %s')
        values.append(f"%{params['pacjent_imie']}%")
    
    if params.get('pacjent_nazwisko'):
        conditions.append('pacjent_nazwisko ILIKE %s')
        values.append(f"%{params['pacjent_nazwisko']}%")
    
    if params.get('pacjent_pesel'):
        conditions.append('pacjent_pesel = %s')
        values.append(params['pacjent_pesel'])
    
    if params.get('pacjent_data_urodzenia'):
        conditions.append('(pacjent_data_urodzenia = %s OR pacjent_data_urodzenia::text = %s OR DATE(pacjent_data_urodzenia) = %s)')
        values.append(params['pacjent_data_urodzenia'])
        values.append(params['pacjent_data_urodzenia'])
        values.append(params['pacjent_data_urodzenia'])

    if params.get('zlecenie_kod_kreskowy'):
        conditions.append('zlecenie_kod_kreskowy ILIKE %s')
        values.append(f"%{params['zlecenie_kod_kreskowy']}%")
    if params.get('lekarz_imie'):
        conditions.append('lekarz_imie ILIKE %s')
        values.append(f"%{params['lekarz_imie']}%")
    if params.get('lekarz_nazwisko'):
        conditions.append('lekarz_nazwisko ILIKE %s')
        values.append(f"%{params['lekarz_nazwisko']}%")
    if params.get('zleceniodawca_nazwa'):
        conditions.append('zleceniodawca_nazwa ILIKE %s')
        values.append(f"%{params['zleceniodawca_nazwa']}%")
    if params.get('zleceniodawca_kod_lsi'):
        conditions.append('zleceniodawca_kod_lsi ILIKE %s')
        values.append(f"%{params['zleceniodawca_kod_lsi']}%")
    if params.get('zleceniodawca_nip'):
        conditions.append('zleceniodawca_nip ILIKE %s')
        values.append(f"%{params['zleceniodawca_nip']}%")
    if params.get('zlecenie_data_od'):
        conditions.append('zlecenie_data >= %s')
        values.append(params['zlecenie_data_od'])
    if params.get('zlecenie_data_do'):
        conditions.append('zlecenie_data <= %s')
        values.append(params['zlecenie_data_do'])

    where_clause = ""
    if conditions:
        where_clause = "WHERE " + " AND ".join(conditions)

    # Zapytanie o caÅ‚kowitÄ… liczbÄ™ wynikÃ³w
    count_sql = f'''SELECT COUNT(*) as total FROM wynikowe_dane.wyniki {where_clause}'''
    count_result = db.dict_select(count_sql, values)
    total_count = count_result[0]['total'] if count_result else 0
    
    # Zapytanie o dane - pobierz wszystkie lub z paginacjÄ…
    if fetch_all:
        # Pobierz wszystkie dane za jednym razem
        sql = f'''SELECT id, common_table_name, laboratorium, zlecenie_kod_kreskowy, 
                  zlecenie_recno, zlecenie_rekno, zlecenie_data, pacjent_imie, pacjent_nazwisko, 
                  pacjent_data_urodzenia, pacjent_pesel, lekarz_imie, lekarz_nazwisko, lekarz_numer,
                  zleceniodawca_kod_lsi, zleceniodawca_nazwa, zleceniodawca_nip 
                  FROM wynikowe_dane.wyniki {where_clause} 
                  ORDER BY id'''
        print(f"DEBUG - Pobieranie WSZYSTKICH danych: {sql}")
        print(f"DEBUG - WartoÅ›ci SQL: {values}")
        results = db.dict_select(sql, values)
    else:
        # Pobierz dane z paginacjÄ…
        sql = f'''SELECT id, common_table_name, laboratorium, zlecenie_kod_kreskowy, 
                  zlecenie_recno, zlecenie_rekno, zlecenie_data, pacjent_imie, pacjent_nazwisko, 
                  pacjent_data_urodzenia, pacjent_pesel, lekarz_imie, lekarz_nazwisko, lekarz_numer,
                  zleceniodawca_kod_lsi, zleceniodawca_nazwa, zleceniodawca_nip 
                  FROM wynikowe_dane.wyniki {where_clause} 
                  ORDER BY id
                  LIMIT %s OFFSET %s'''
        print(f"DEBUG - Pobieranie danych z paginacjÄ…: {sql}")
        print(f"DEBUG - WartoÅ›ci SQL: {values + [page_size, offset]}")
        results = db.dict_select(sql, values + [page_size, offset])
    
    print(f"DEBUG - Liczba zwrÃ³conych wynikÃ³w: {len(results) if results else 0}")
    
    # Debugowanie - sprawdÅºmy kilka przykÅ‚adowych dat z bazy
    if not results and any('pacjent_data_urodzenia' in condition for condition in conditions):
        debug_sql = "SELECT DISTINCT pacjent_data_urodzenia, pacjent_imie, pacjent_nazwisko FROM wynikowe_dane.wyniki WHERE pacjent_data_urodzenia IS NOT NULL LIMIT 10"
        debug_results = db.dict_select(debug_sql, [])
        print(f"DEBUG - PrzykÅ‚adowe daty urodzenia w bazie: {debug_results}")

    if not results or len(results) == 0:
        return {
            "type": "info",
            "text": "Brak danych speÅ‚niajÄ…cych podane kryteria. SprÃ³buj poszerzyÄ‡ zakres dat lub zmieniÄ‡ filtry."
        }

    header = [
        'ID', 'Tabela ÅºrÃ³dÅ‚owa', 'Laboratorium', 'Kod kreskowy zlecenia',
        'Numer wewnÄ™trzny zlecenia (recno)', 'Numer rekordu zlecenia (rekno)', 'Data zlecenia',
        'ImiÄ™ pacjenta', 'Nazwisko pacjenta', 'Data urodzenia pacjenta', 'PESEL pacjenta',
        'ImiÄ™ lekarza', 'Nazwisko lekarza', 'Numer lekarza',
        'Kod LSI zleceniodawcy', 'Nazwa zleceniodawcy', 'NIP zleceniodawcy'
    ]

    columns = [
        'id', 'common_table_name', 'laboratorium', 'zlecenie_kod_kreskowy',
        'zlecenie_recno', 'zlecenie_rekno', 'zlecenie_data',
        'pacjent_imie', 'pacjent_nazwisko', 'pacjent_data_urodzenia', 'pacjent_pesel',
        'lekarz_imie', 'lekarz_nazwisko', 'lekarz_numer',
        'zleceniodawca_kod_lsi', 'zleceniodawca_nazwa', 'zleceniodawca_nip'
    ]

    data = [[row.get(col) for col in columns] for row in results]

    # Informacje o paginacji
    if fetch_all:
        # JeÅ›li pobrano wszystkie dane, podziel je na strony
        total_pages = (len(data) + page_size - 1) // page_size if data else 0
        start_idx = (page - 1) * page_size
        end_idx = start_idx + page_size
        current_page_data = data[start_idx:end_idx]
    else:
        # Standardowa paginacja
        total_pages = (total_count + page_size - 1) // page_size if total_count > 0 else 0
        current_page_data = data
    
    if generate_pdf or generate_all_from_page or generate_selected or generate_background:
        # SprawdÅº czy to generowanie w tle
        if generate_background:
            print(f"DEBUG - Generowanie w tle - przekierowujÄ™ do standardowego generowania")
            # Dla generowania w tle, przekieruj do standardowego generowania
            # (opcja w tle nie jest jeszcze w peÅ‚ni zaimplementowana)
            if generate_all_from_page or generate_selected:
                # JeÅ›li wybrano "wszystkie" lub "zaznaczone", uÅ¼yj tych ID
                if generate_all_from_page:
                    sql = f'''SELECT id FROM wynikowe_dane.wyniki {where_clause} ORDER BY id'''
                    results = db.dict_select(sql, values)
                    if not results:
                        return {"type": "info", "text": "Brak danych do pobrania."}
                    ids = [row['id'] for row in results]
                else:  # generate_selected
                    if not selected_ids:
                        return {"type": "info", "text": "Nie zaznaczono Å¼adnych ID do pobrania."}
                    ids = [int(id_.strip()) for id_ in selected_ids.split(',') if id_.strip().isdigit()]
            else:
                # Standardowo uÅ¼yj ID z aktualnej strony
                if fetch_all:
                    start_idx = (page - 1) * page_size
                    end_idx = start_idx + page_size
                    current_page_ids = [row['id'] for row in results[start_idx:end_idx]]
                    ids = current_page_ids
                else:
                    if not selected_ids:
                        return {"type": "info", "text": "Nie wybrano Å¼adnych ID do pobrania."}
                    ids = [int(id_.strip()) for id_ in selected_ids.split(',') if id_.strip().isdigit()]
            
            print(f"DEBUG - Generowanie w tle dla {len(ids)} ID - kontynuujÄ™ standardowe generowanie")
            # Kontynuuj standardowe generowanie zamiast zwracaÄ‡ komunikat
        
        # Standardowa logika dla generowania synchronicznego
        if generate_all_from_page:
            # Pobierz wszystkie ID z wszystkich danych (bez paginacji)
            sql = f'''SELECT id FROM wynikowe_dane.wyniki {where_clause} 
                      ORDER BY id'''
            results = db.dict_select(sql, values)
            if not results:
                return {"type": "info", "text": "Brak danych do pobrania."}
            ids = [row['id'] for row in results]
            print(f"DEBUG - Automatycznie pobrano {len(ids)} ID ze wszystkich danych")
        elif generate_selected:
            # Pobierz ID z zaznaczonych checkboxÃ³w
            if not selected_ids:
                return {"type": "info", "text": "Nie zaznaczono Å¼adnych ID do pobrania. Zaznacz checkboxy przy wybranych wierszach."}
            ids = [int(id_.strip()) for id_ in selected_ids.split(',') if id_.strip().isdigit()]
            if not ids:
                return {"type": "info", "text": "Brak prawidÅ‚owych zaznaczonych ID do pobrania."}
            print(f"DEBUG - Pobrano {len(ids)} zaznaczonych ID: {ids}")
        else:
            # Standardowa logika dla wybranych ID (z aktualnej strony)
            if fetch_all:
                # JeÅ›li pobrano wszystkie dane, uÅ¼yj ID z aktualnej strony
                start_idx = (page - 1) * page_size
                end_idx = start_idx + page_size
                current_page_ids = [row['id'] for row in results[start_idx:end_idx]]
                ids = current_page_ids
                print(f"DEBUG - Pobrano {len(ids)} ID z aktualnej strony: {ids}")
            else:
                # UÅ¼yj ID z pola tekstowego
                if not selected_ids:
                    return {"type": "info", "text": "Nie wybrano Å¼adnych ID do pobrania."}
                ids = [int(id_.strip()) for id_ in selected_ids.split(',') if id_.strip().isdigit()]
                if not ids:
                    return {"type": "info", "text": "Brak prawidÅ‚owych ID do pobrania."}

        try:
            print(f"DEBUG - Rozpoczynam generowanie plikÃ³w dla {len(ids)} ID")
            print(f"DEBUG - Typ pliku: {file_type}, PDF mode: {params.get('pdf_mode', 'single')}")
            
            # Limit liczby plikÃ³w do generowania (zabezpieczenie przed przeciÄ…Å¼eniem)
            max_files = 1000
            if len(ids) > max_files:
                print(f"DEBUG - Przekroczono limit plikÃ³w: {len(ids)} > {max_files}")
                return {"type": "info", "text": f"Za duÅ¼o wynikÃ³w do pobrania ({len(ids)}). Maksymalnie moÅ¼na pobraÄ‡ {max_files} plikÃ³w na raz."}
            
            files = []

            if file_type == "cda":
                print(f"DEBUG - Generowanie plikÃ³w CDA dla {len(ids)} ID")
                sql = "SELECT id, zlecenie FROM wynikowe_dane.wyniki WHERE id = ANY(%s)"
                results = db.dict_select(sql, [ids])
                if not results:
                    print(f"DEBUG - Nie znaleziono wynikÃ³w CDA dla ID: {ids[:10]}...")
                    return {"type": "info", "text": f"Nie znaleziono wynikÃ³w dla podanych ID w bazie danych."}
                
                print(f"DEBUG - Znaleziono {len(results)} wynikÃ³w CDA")
                processed_count = 0
                for row in results:
                    id_ = row.get("id")
                    zlecenie = row.get("zlecenie", {})
                    pre = zlecenie.get("PREPROCESSED", {})
                    if format_cda == "cda":
                        cda_hex = pre.get("PADES", {}).get("CDA")
                        filename = f"wynik_{id_}.xml"
                        mimetype = "text/xml"
                    else:
                        cda_hex = pre.get("PADES", {}).get("PDF")
                        filename = f"wynik_{id_}.pdf"
                        mimetype = "application/pdf"
                    if not cda_hex:
                        print(f"DEBUG - Brak danych CDA dla ID {id_}")
                        continue 
                    try:
                        if cda_hex.startswith("\\x"):
                            cda_bytes = bytes.fromhex(cda_hex[2:])
                        else:
                            cda_bytes = base64.b64decode(cda_hex)
                    except Exception as e:
                        print(f"DEBUG - BÅ‚Ä…d dekodowania CDA dla ID {id_}: {e}")
                        cda_bytes = cda_hex.encode("utf-8") 
                    files.append({
                        "filename": filename,
                        "content": base64.b64encode(cda_bytes).decode("utf-8"),
                        "mimetype": mimetype
                    })
                    processed_count += 1
                    if processed_count % 100 == 0:
                        print(f"DEBUG - Przetworzono {processed_count}/{len(results)} plikÃ³w CDA")
                
                print(f"DEBUG - Wygenerowano {len(files)} plikÃ³w CDA")
            elif file_type == "pdf":
                print(f"DEBUG - Generowanie plikÃ³w PDF dla {len(ids)} ID")
                pdf_mode = params.get("pdf_mode", "single")
                print(f"DEBUG - PDF mode: {pdf_mode}")
                
                if pdf_mode == "combined":
                    print(f"DEBUG - Generowanie poÅ‚Ä…czonego PDF dla wszystkich {len(ids)} ID")
                    # Optymalizacja: jeden wywoÅ‚anie dla wszystkich ID
                    pdf_result = db.dict_select('SELECT wynikowe_dane.generuj_pdf_z_wynikami(%s) AS pdf_base64', [ids])
                    if not pdf_result or not pdf_result[0].get('pdf_base64'):
                        print(f"DEBUG - BÅ‚Ä…d generowania poÅ‚Ä…czonego PDF")
                        return {"type": "info", "text": "Nie udaÅ‚o siÄ™ wygenerowaÄ‡ PDF-a lub brak danych."}
                    print(f"DEBUG - PomyÅ›lnie wygenerowano poÅ‚Ä…czony PDF")
                    files.append({
                        "filename": "raport_wyniki.pdf",
                        "content": pdf_result[0]['pdf_base64'],
                        "mimetype": "application/pdf"
                    })
                else:
                    print(f"DEBUG - Generowanie pojedynczych PDF-Ã³w w trybie batch")
                    # Optymalizacja: batch processing dla pojedynczych PDF-Ã³w
                    batch_size = 50  # Przetwarzaj po 50 ID na raz
                    total_batches = (len(ids) + batch_size - 1) // batch_size
                    print(f"DEBUG - Przetwarzanie {len(ids)} ID w {total_batches} partiach po {batch_size}")
                    
                    for i in range(0, len(ids), batch_size):
                        batch_num = i // batch_size + 1
                        batch_ids = ids[i:i + batch_size]
                        print(f"DEBUG - Przetwarzanie partii {batch_num}/{total_batches} ({len(batch_ids)} ID)")
                        
                        # WywoÅ‚aj funkcjÄ™ dla caÅ‚ej partii
                        result = db.dict_select('SELECT wynikowe_dane.generuj_pdf_z_wynikami(%s) AS pdf_base64', [batch_ids])
                        if result and result[0].get("pdf_base64"):
                            # JeÅ›li funkcja zwraca jeden plik dla partii, dodaj go
                            print(f"DEBUG - PomyÅ›lnie wygenerowano PDF dla partii {batch_num}")
                            files.append({
                                "filename": f"raport_batch_{batch_num}.pdf",
                                "content": result[0]['pdf_base64'],
                                "mimetype": "application/pdf"
                            })
                        else:
                            # JeÅ›li funkcja nie obsÅ‚uguje batch, wywoÅ‚aj dla kaÅ¼dego ID osobno
                            print(f"DEBUG - Batch nie dziaÅ‚a, generowanie pojedynczych PDF-Ã³w dla partii {batch_num}")
                            for j, id_ in enumerate(batch_ids):
                                print(f"DEBUG - Generowanie PDF dla ID {id_} ({j+1}/{len(batch_ids)} w partii {batch_num})")
                                single_result = db.dict_select('SELECT wynikowe_dane.generuj_pdf_z_wynikami(%s) AS pdf_base64', [[id_]])
                                if single_result and single_result[0].get("pdf_base64"):
                                    files.append({
                                        "filename": f"raport_{id_}.pdf",
                                        "content": single_result[0]['pdf_base64'],
                                        "mimetype": "application/pdf"
                                    })
                                    print(f"DEBUG - PomyÅ›lnie wygenerowano PDF dla ID {id_}")
                                else:
                                    print(f"DEBUG - BÅ‚Ä…d generowania PDF dla ID {id_}")
                
                print(f"DEBUG - Wygenerowano {len(files)} plikÃ³w PDF")
            
            if not files:
                print(f"DEBUG - Brak plikÃ³w do spakowania")
                return {"type": "info", "text": f"Nie udaÅ‚o siÄ™ wygenerowaÄ‡ Å¼adnych plikÃ³w ({file_type})."}

            print(f"DEBUG - Tworzenie archiwum ZIP z {len(files)} plikÃ³w")
            # Optymalizacja: kompresja ZIP z lepszymi ustawieniami
            with tempfile.NamedTemporaryFile(delete=False, suffix=".zip") as tmp_zip:
                print(f"DEBUG - Tymczasowy plik ZIP: {tmp_zip.name}")
                with zipfile.ZipFile(tmp_zip.name, 'w', compression=zipfile.ZIP_DEFLATED, compresslevel=6) as zipf:
                    for i, file in enumerate(files):
                        print(f"DEBUG - Dodawanie pliku {i+1}/{len(files)}: {file['filename']}")
                        decoded = base64.b64decode(file['content'])
                        zipf.writestr(file['filename'], decoded)
                print(f"DEBUG - Archiwum ZIP utworzone, rozmiar: {os.path.getsize(tmp_zip.name)} bajtÃ³w")
                tmp_zip.seek(0)
                with open(tmp_zip.name, "rb") as f:
                    zip_content = f.read()
                os.unlink(tmp_zip.name)
                print(f"DEBUG - Tymczasowy plik usuniÄ™ty")

            print(f"DEBUG - Kodowanie ZIP do base64")
            zip_base64 = base64.b64encode(zip_content).decode("utf-8")
            print(f"DEBUG - Rozmiar base64: {len(zip_base64)} znakÃ³w")

            return {
                "type": "base64file",
                "filename": f"raporty_{file_type}_{len(files)}_plikow.zip",
                "content": zip_base64,
                "mimetype": "application/zip"
            }

        except Exception as e:
            print(f"DEBUG - BÅ‚Ä…d podczas generowania plikÃ³w: {e}")
            traceback.print_exc()
            return {"type": "info", "text": f"BÅ‚Ä…d podczas generowania plikÃ³w: {e}"}


    return {
        "type": "table",
        "header": header,
        "data": prepare_for_json(current_page_data),
        "show_checkboxes": True,  # Flaga dla frontendu
        "actions": ["xlsx"],  # Dodaj akcjÄ™ Excel
        "pagination": {
            "current_page": page,
            "page_size": page_size,
            "total_count": total_count if not fetch_all else len(data),
            "total_pages": total_pages,
            "has_next": page < total_pages,
            "has_prev": page > 1
        },
        "all_data": prepare_for_json(data) if fetch_all else None  # Wszystkie dane dla cache'a
    }
